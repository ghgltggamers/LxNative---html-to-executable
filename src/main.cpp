// This is main file for handeling main compilation.
#include "lx_parser.hpp"
#include "zip.hpp"

int main(int argc, char * argv[]){
    std::string project_path = argv[1];
    std::cout<<"main -> Creating a praser...";
    lx_parser parser;
    std::cout<<"main -> A parser was created\nmain -> parsing the project\n";
    parser.parse.lx_project_info(project_path);
    std::string bpath = "mkdir " + project_path + "/" + parser.parse.lx_project_pckg;
    std::system(bpath.c_str());
    // std::cout<<bpath;
    std::string cpath = project_path + "/" + parser.parse.lx_project_pckg +"/project.lx.native.cc";
    std::ofstream ocpp(cpath);
    // std::string code = "#include <gtk/gtk.h>#include <webkit2/webkit2.h>#include <iostream>#include <fstream>#include <sstream>#include <thread>#include <boost/asio.hpp>#include <filesystem>#include <csignal>using namespace std;using namespace boost::asio;const char* window_title = \""+ parser.parse.lx_project_name +"\";const char* window_icon = \"licox64.png\";const int port = "+parser.parse.lx_project_port+";const std::string assets_dir = \"assets\";bool running = true;void start_server() { io_service io_service; ip::tcp::acceptor acceptor(io_service, ip::tcp::endpoint(ip::tcp::v4(), port)); while (running) { ip::tcp::socket socket(io_service); acceptor.accept(socket); char request[1024]; socket.read_some(boost::asio::buffer(request)); std::string request_str(request); std::string requested_file = request_str.substr(4, request_str.find(\" \", 4) - 4); if (requested_file == \"/\") { requested_file = \"/index.html\"; } std::string file_path = assets_dir + requested_file; std::ifstream file(file_path); std::stringstream response; if (file) { std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>()); response << \"HTTP/1.1 200 OK\\r\\n\"; response << \"Content-Type: text/html\\r\\n\"; response << \"Content-Length: \" << content.length() << \"\\r\\n\"; response << \"\\r\\n\"; response << content; } else { response << \"HTTP/1.1 404 Not Found\\r\\n\"; response << \"Content-Type: text/html\\r\\n\"; response << \"Content-Length: 36\\r\\n\"; response << \"\\r\\n\"; response << \"<h1>404 Not Found</h1>\"; } boost::asio::write(socket, boost::asio::buffer(response.str())); } acceptor.close(); } void signal_handler(int signal) { running = false; } void on_window_destroy(GtkWidget* widget, gpointer data) { running = false; gtk_main_quit(); } static void activate(GtkApplication* app, gpointer user_data) { GtkWidget* window = gtk_application_window_new(app); gtk_window_set_title(GTK_WINDOW(window), window_title); gtk_window_set_default_size(GTK_WINDOW(window), 800, 600); GdkPixbuf* icon = gdk_pixbuf_new_from_file(window_icon, NULL); gtk_window_set_icon(GTK_WINDOW(window), icon); WebKitWebView* web_view = WEBKIT_WEB_VIEW(webkit_web_view_new()); gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(web_view)); std::string url = \"http://localhost:\" + std::to_string(port); webkit_web_view_load_uri(web_view, url.c_str()); g_signal_connect(window, \"destroy\", G_CALLBACK(on_window_destroy), NULL); g_signal_connect(window, \"destroy\", G_CALLBACK(exit), NULL); gtk_widget_show_all(window); } int main(int argc, char* argv[]) { std::signal(SIGINT, signal_handler); std::signal(SIGTERM, signal_handler); std::thread server_thread(start_server); GtkApplication* app = gtk_application_new(\""+parser.parse.lx_project_pckg+"\", G_APPLICATION_FLAGS_NONE); g_signal_connect(app, \"activate\", G_CALLBACK(activate), NULL); int status = g_application_run(G_APPLICATION(app), argc, argv); running = false; server_thread.join(); g_object_unref(app); return status; }";
    std::string code = "#include <gtk/gtk.h>\n#include <webkit2/webkit2.h>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <thread>\n#include <boost/asio.hpp>\n#include <filesystem>\n#include <csignal>\nusing namespace std;\nusing namespace boost::asio;\nconst char* window_title = \"" + parser.parse.lx_project_name + "\";\nconst char* window_icon = \"licox64.png\";\nconst int port = " + parser.parse.lx_project_port + ";\nconst std::string assets_dir = \"assets\";\nbool running = true;\nvoid start_server() {\nio_service io_service;\nip::tcp::acceptor acceptor(io_service, ip::tcp::endpoint(ip::tcp::v4(), port));\nwhile (running) {\nip::tcp::socket socket(io_service);\nacceptor.accept(socket);\nchar request[1024];\nsocket.read_some(boost::asio::buffer(request));\nstd::string request_str(request);\nstd::string requested_file = request_str.substr(4, request_str.find(\" \", 4) - 4);\nif (requested_file == \"/\") {\nrequested_file = \"/index.html\";\n}\nstd::string file_path = assets_dir + requested_file;\nstd::ifstream file(file_path);\nstd::stringstream response;\nif (file) {\nstd::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\nresponse << \"HTTP/1.1 200 OK\\r\\n\";\nresponse << \"Content-Type: text/html\\r\\n\";\nresponse << \"Content-Length: \" << content.length() << \"\\r\\n\";\nresponse << \"\\r\\n\";\nresponse << content;\n} else {\nresponse << \"HTTP/1.1 404 Not Found\\r\\n\";\nresponse << \"Content-Type: text/html\\r\\n\";\nresponse << \"Content-Length: 36\\r\\n\";\nresponse << \"\\r\\n\";\nresponse << \"<h1>404 Not Found</h1>\";\n}\nboost::asio::write(socket, boost::asio::buffer(response.str()));\n}\nacceptor.close();\n}\nvoid signal_handler(int signal) {\nrunning = false;\n}\nvoid on_window_destroy(GtkWidget* widget, gpointer data) {\nrunning = false;\ngtk_main_quit();\n}\nstatic void activate(GtkApplication* app, gpointer user_data) {\nGtkWidget* window = gtk_application_window_new(app);\ngtk_window_set_title(GTK_WINDOW(window), window_title);\ngtk_window_set_default_size(GTK_WINDOW(window), 800, 600);\nGdkPixbuf* icon = gdk_pixbuf_new_from_file(window_icon, NULL);\ngtk_window_set_icon(GTK_WINDOW(window), icon);\nWebKitWebView* web_view = WEBKIT_WEB_VIEW(webkit_web_view_new());\ngtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(web_view));\nstd::string url = \"http://localhost:\" + std::to_string(port);\nwebkit_web_view_load_uri(web_view, url.c_str());\ng_signal_connect(window, \"destroy\", G_CALLBACK(on_window_destroy), NULL);\ng_signal_connect(window, \"destroy\", G_CALLBACK(exit), NULL);\ngtk_widget_show_all(window);\n}\nint main(int argc, char* argv[]) {\nstd::signal(SIGINT, signal_handler);\nstd::signal(SIGTERM, signal_handler);\nstd::thread server_thread(start_server);\nGtkApplication* app = gtk_application_new(\"" + parser.parse.lx_project_pckg + "\", G_APPLICATION_FLAGS_NONE);\ng_signal_connect(app, \"activate\", G_CALLBACK(activate), NULL);\nint status = g_application_run(G_APPLICATION(app), argc, argv);\nrunning = false;\nserver_thread.join();\ng_object_unref(app);\nreturn status;\n}";

    ocpp<<code;
    std::string command = "g++ "+cpath+" `pkg-config --cflags --libs gtk+-3.0 webkit2gtk-4.0`";
    std::ofstream cfile(project_path + "/" + parser.parse.lx_project_pckg + "/lxbuild.sh");
    cfile<<command;

    bpath += "/assets/";
    std::system(bpath.c_str());
    ZipExtractor extractor(project_path + "/" + parser.parse.lx_project_include, project_path + "/"+parser.parse.lx_project_pckg + "/assets/");

    extractor.extract();

    std::cout<<"\n\n\n\n\nThe project with name "<<parser.parse.lx_project_name<<", pckg : "<<parser.parse.lx_project_pckg<<" was successfully created please open the pckg and compile your project by executing the compile script.\n";
}